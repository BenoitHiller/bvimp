#!/bin/bash

set -f

source "json.bash"

declare -r REPOSITORY_REGEX='^([a-zA-Z0-9_-]+)/([a-zA-Z0-9_.-]+)$'
declare -r NAME_REGEX='^[a-zA-Z0-9_-]+$'
declare BVIMP_HOME="$HOME/.vim/pack/bvimp"

getLocalPackageData() {
  local user
  local repository
  for package in "$@"; do
    if [[ -z "${packageStrings[$package]+_}" ]]; then
      if [[ "$package" =~ $REPOSITORY_REGEX ]]; then
        user="${BASH_REMATCH[1]}"
        repository="${BASH_REMATCH[2]}"

        packageStrings["$package"]="$repository@$user"
      else
        invalidPackages["$package"]="Invalid Package specified"
      fi
    fi
  done
}

validatePackageData() {
  for package in "${!invalidPackages[@]}"; do
    printf "%s: %s\n" "${invalidPackages[$package]}" "$package" >&2
  done

  if [[ "${#invalidPackages[@]}" -gt 0 ]]; then
    printf "No packages installed\n" >&2
    return 1
  fi
}

checkInstall() {
  (
    set -e
    cd "$BVIMP_HOME"
    git=$(git rev-parse --git-dir)
    [[ "$git" == ".git" ]]
  ) 
  local ret="$?"
  if [[ "$ret" != 0 ]]; then
    printf "Error: you have not initialized bvimp. Call \`bvimp init\` to fix this.\n" >&2
  fi
  return $ret
}

bvimp_init() {
  {
    mkdir -p "$BVIMP_HOME"
    (
      cd "$BVIMP_HOME"
      git init
    )
  }
}

bvimp_add() {
  local -A queryResults
  local tmpFile
  local code
  local repoName
  local repoPath
  for target in "${!packageStrings[@]}"; do
    queryResults=()
    tmpFile="$(mktemp -t 'bvimp.XXXX.json')"
    code="$(curl -s -w '%{http_code}' -o "$tmpFile" "https://api.github.com/repos/$target")"

    if [[ "$code" == 200 ]]; then
      repoName="${packageStrings[$target]}"
      repoPath="start/$repoName"
      parseJson queryResults <"$tmpFile" 
      rm "$tmpFile"
      if [[ -d "$BVIMP_HOME/$repoPath" ]]; then
        # TODO desired behaviour is probably update
        printf "Package named %s already exists\n" "$target" >&2
        return 1
      fi
      (
        cd "$BVIMP_HOME"
        # TODO this can fail...
        git submodule add "${queryResults[./clone_url]}" "$repoPath"
        git add "$repoPath" .gitmodules
        git commit -q -m "Adding $repoName" 
      )
    elif [[ "$code" == 404 ]]; then
      printf "Package not found: %s\n" "$target" >&2
      rm "$tmpFile"
      return 1
    fi
  done
}

bvimp_remove() {
  local repoName
  local repoPath
  for target in "${!packageStrings[@]}"; do

    repoName="${packageStrings[$target]}"
    repoPath="start/$repoName"
    if [[ ! -d "$BVIMP_HOME/$repoPath" ]]; then
      printf "Package not found: %s\n" "$target" >&2
      return 1
    fi
    (
      cd "$BVIMP_HOME"
      # TODO this can fail...
      git submodule deinit "$repoPath"
      git rm "$repoPath"
      git commit -q -m "Removing $repoName" 
      rm -rf ".git/modules/$repoPath"
    )
  done
}

bvimp_update() {
  (
    cd "$BVIMP_HOME"
    # TODO this can fail...
    git submodule update --remote --merge
    git commit -a -q -m "Updating packages" 
  )
  
}

bvimp_list() {
  git config --file "$BVIMP_HOME/.gitmodules" --get-regexp url\$ \
    | awk '{ printf("%s\t%s\n", gensub(/.*\/([^\/@]+)@([^\/@]+)\.url$/, "\\2/\\1", 1, $1), $2) }'
}

main() {
  local -A packageStrings
  local -A invalidPackages
  if [[ "$#" -gt 0 ]]; then
    # TODO command parsing
    #
    # The final architecture of this program should be something that separates
    # the components of command parsing, querying metadata, and actually
    # modifying the filesystem.
    #
    # First compile all of the passed parameters into a list of packages. Then
    # determine the current state of those packages, as well as their full
    # names and clone urls. Then finally use dumb update methods that just add,
    # remove, and update submodules using source and destination parameters.
    local command="$1"
    case "$command" in
      add)
        checkInstall || exit 1
        shift
        getLocalPackageData "$@"
        validatePackageData || exit 1
        bvimp_add
        ;;
      remove)
        checkInstall || exit 1
        shift
        getLocalPackageData "$@"
        validatePackageData || exit 1
        bvimp_remove
        ;;
      update)
        # TODO single package update
        checkInstall || exit 1
        bvimp_update
        ;;
      list)
        checkInstall || exit 1
        bvimp_list
        ;;
      init)
        bvimp_init
        ;;
      *)
        printf "Command not found: %s\n" "$command" >&2
        ;;
    esac
    return "$?"
  else
    printf "TODO help\n" >&2
  fi
}

main "$@"
